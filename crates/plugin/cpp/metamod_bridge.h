#pragma once

#include <cstdint>
#include <ISmmPlugin.h>

// Minimal stub for IServerGameDLL that matches the vtable layout
// This avoids dragging in the full HL2SDK with protobuf dependencies
//
// IServerGameDLL is typedef'd from ISource2Server which inherits from IAppSystem
// The vtable layout must match exactly for SourceHook to work correctly
//
// IAppSystem methods (0-10):
//   0: Connect, 1: Disconnect, 2: QueryInterface, 3: Init, 4: Shutdown,
//   5: PreShutdown, 6: GetDependencies, 7: GetTier, 8: Reconnect,
//   9: IsSingleton, 10: GetBuildType
//
// ISource2Server methods starting at 11:
//   11: unk_001, 12: SetGlobals, 13: GameCreateNetworkStringTables,
//   14: WriteSignonMessages, 15: PreWorldUpdate, 16: GetEntity2Networkables,
//   17: GetEntityInfo, 18: ApplyGameSettings, 19: GameFrame
class IServerGameDLL
{
public:
    // IAppSystem vtable entries (0-10)
    virtual bool Connect(void*) = 0;                     // 0
    virtual void Disconnect() = 0;                       // 1
    virtual void* QueryInterface(const char*) = 0;       // 2
    virtual int Init() = 0;                              // 3
    virtual void Shutdown() = 0;                         // 4
    virtual void PreShutdown() = 0;                      // 5
    virtual void* GetDependencies() = 0;                 // 6
    virtual int GetTier() = 0;                           // 7
    virtual void Reconnect(void*, const char*) = 0;      // 8
    virtual bool IsSingleton() = 0;                      // 9
    virtual int GetBuildType() = 0;                      // 10

    // ISource2Server vtable entries (11-19)
    virtual bool unk_001() = 0;                          // 11
    virtual void SetGlobals(void*) = 0;                  // 12
    virtual void GameCreateNetworkStringTables() = 0;    // 13
    virtual void WriteSignonMessages(void*) = 0;         // 14
    virtual void PreWorldUpdate(bool) = 0;               // 15
    virtual void* GetEntity2Networkables() = 0;          // 16
    virtual void* GetEntityInfo() = 0;                   // 17
    virtual void ApplyGameSettings(void*) = 0;           // 18

    // The method we're hooking - must be at vtable index 19
    virtual void GameFrame(bool simulating, bool bFirstTick, bool bLastTick) = 0;  // 19

    // Additional methods for ServerActivate hook
    virtual void* unk_020() = 0;                             // 20
    virtual void* unk_021() = 0;                             // 21
    virtual void ServerActivate(void* pEdictList, int edictCount, int clientMax) = 0;  // 22
    virtual void GameShutdown() = 0;                         // 23
};

// Stub for IServerGameClients
// This interface handles client connection events
// Interface name: "Source2GameClients001"
class CPlayerSlot
{
public:
    CPlayerSlot(int slot) : m_slot(slot) {}
    int Get() const { return m_slot; }
private:
    int m_slot;
};

class CBufferString;

class IServerGameClients
{
public:
    // IAppSystem vtable entries (0-10) - same as IServerGameDLL
    virtual bool Connect(void*) = 0;
    virtual void Disconnect() = 0;
    virtual void* QueryInterface(const char*) = 0;
    virtual int Init() = 0;
    virtual void Shutdown() = 0;
    virtual void PreShutdown() = 0;
    virtual void* GetDependencies() = 0;
    virtual int GetTier() = 0;
    virtual void Reconnect(void*, const char*) = 0;
    virtual bool IsSingleton() = 0;
    virtual int GetBuildType() = 0;

    // IServerGameClients methods
    virtual bool ClientConnect(CPlayerSlot slot, const char* pszName, uint64_t xuid,
                               const char* pszNetworkID, bool unk1, CBufferString* pRejectReason) = 0;  // 11
    virtual void OnClientConnected(CPlayerSlot slot, const char* pszName, uint64_t xuid,
                                   const char* pszNetworkID, const char* pszIP, bool bFakePlayer) = 0;  // 12
    virtual void ClientFullyConnect(CPlayerSlot slot) = 0;  // 13
    virtual void ClientPutInServer(CPlayerSlot slot, const char* pszName, int type, uint64_t xuid) = 0;  // 14
    virtual void ClientDisconnect(CPlayerSlot slot, int reason, const char* pszName,
                                  uint64_t xuid, const char* pszNetworkID) = 0;  // 15
    virtual void ClientVoice(CPlayerSlot slot) = 0;  // 16
    virtual void ClientCommand(CPlayerSlot slot, void* args) = 0;  // 17
};

// Entity instance opaque type
class CEntityInstance;

// IEntityListener interface for entity lifecycle events
class IEntityListener
{
public:
    virtual void OnEntityCreated(CEntityInstance* pEntity) {}
    virtual void OnEntitySpawned(CEntityInstance* pEntity) {}
    virtual void OnEntityDeleted(CEntityInstance* pEntity) {}
    virtual void OnEntityParentChanged(CEntityInstance* pEntity, CEntityInstance* pNewParent) {}
};

// Forward declarations for Rust exports
// These are defined in rust_exports.h (generated by cbindgen) but we declare them
// here as fallback in case the header doesn't exist yet during first build
#ifdef __cplusplus
extern "C" {
#endif

// Updated signature to receive factory functions for interface acquisition
bool rust_plugin_load(
    int plugin_id,
    void* ismm,
    void* server_factory,
    void* engine_factory,
    char* error,
    size_t maxlen,
    bool late
);
bool rust_plugin_unload(char* error, size_t maxlen);

// GameFrame callback
void rust_on_game_frame(bool simulating, bool first_tick, bool last_tick);

// Listener callbacks
void rust_on_map_start(const char* map_name);
void rust_on_map_end();
void rust_on_client_connect(int slot, const char* name, const char* ip);
void rust_on_client_disconnect(int slot);
void rust_on_client_put_in_server(int slot);
void rust_on_entity_created(void* entity);
void rust_on_entity_spawned(void* entity);
void rust_on_entity_deleted(void* entity);

// Metadata
const char* rust_get_author();
const char* rust_get_name();
const char* rust_get_description();
const char* rust_get_url();
const char* rust_get_license();
const char* rust_get_version();
const char* rust_get_date();
const char* rust_get_log_tag();

#ifdef __cplusplus
}
#endif

class CS2RustPlugin : public ISmmPlugin
{
public:
    bool Load(PluginId id, ISmmAPI* ismm, char* error, size_t maxlen, bool late) override;
    bool Unload(char* error, size_t maxlen) override;
    bool Pause(char* error, size_t maxlen) override;
    bool Unpause(char* error, size_t maxlen) override;
    void AllPluginsLoaded() override;

    const char* GetAuthor() override;
    const char* GetName() override;
    const char* GetDescription() override;
    const char* GetURL() override;
    const char* GetLicense() override;
    const char* GetVersion() override;
    const char* GetDate() override;
    const char* GetLogTag() override;

public:
    // Hook callbacks (called by SourceHook)
    void Hook_GameFrame(bool simulating, bool bFirstTick, bool bLastTick);
    void Hook_ServerActivate(void* pEdictList, int edictCount, int clientMax);
    void Hook_GameShutdown();
    bool Hook_ClientConnect(CPlayerSlot slot, const char* pszName, uint64_t xuid,
                            const char* pszNetworkID, bool unk1, CBufferString* pRejectReason);
    void Hook_ClientPutInServer(CPlayerSlot slot, const char* pszName, int type, uint64_t xuid);
    void Hook_ClientDisconnect(CPlayerSlot slot, int reason, const char* pszName,
                               uint64_t xuid, const char* pszNetworkID);
};

// Entity listener bridge that forwards to Rust
class CEntityListenerBridge : public IEntityListener
{
public:
    void OnEntityCreated(CEntityInstance* pEntity) override;
    void OnEntitySpawned(CEntityInstance* pEntity) override;
    void OnEntityDeleted(CEntityInstance* pEntity) override;
};

extern CS2RustPlugin g_CS2RustPlugin;
extern CEntityListenerBridge g_EntityListener;

// Interface storage
extern IServerGameDLL* g_pServerGameDLL;
extern IServerGameClients* g_pServerGameClients;

PLUGIN_GLOBALVARS();
